<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爪驻 注专爪</title>

    <!-- Google Analytics Script -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J5WT91REYB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J5WT91REYB');
    </script>

    <!-- HLS.js Library for HLS streams -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Feather Icons for clear UI icons -->
    <script src="https://unpkg.com/feather-icons"></script>

    <style>
        :root {
            --bg-color: #0a0a0a;
            --header-bg-color: #1a1a1a;
            --nav-bg-color: #1f2937; /* bg-gray-800 */
            /* Updated button colors for higher contrast */
            --nav-btn-bg-color: #3b82f6; /* A clear blue, bg-blue-500 */
            --nav-btn-active-bg-color: #10b981; /* A bright green, bg-emerald-500 */
            --text-color: #f9fafb; /* text-gray-50 */
            --text-color-inactive: #e5e7eb; /* text-gray-200 for better readability on blue */
        }

        /* --- General Body and Typography --- */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Heebo', sans-serif;
            margin: 0;
            padding-bottom: 90px; /* Reserve space for bottom nav bar */
        }

        /* --- Main Content and Video Grid --- */
        .main-content {
            padding: 1.5rem 1rem;
        }

        .video-container {
            position: relative;
            aspect-ratio: 16/9;
            border-radius: 12px;
            overflow: hidden;
            background-color: #000;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            transition: transform 0.2s ease-in-out;
        }

        .video-container video, .video-container iframe {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* --- Per-Video Controls (Grid View) --- */
        .grid-controls-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(2px);
        }

        .video-container:hover .grid-controls-overlay {
            opacity: 1;
        }

        .channel-name-bar {
            width: 100%;
            text-align: right;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
            color: white;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .grid-control-buttons {
            display: flex;
            gap: 1rem;
            padding-bottom: 1rem;
        }

        .control-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            width: 44px;
            height: 44px;
        }

        .control-btn:hover {
             transform: scale(1.1);
            background: rgba(55, 65, 81, 0.9);
         }

        /* --- Redesigned Bottom Navigation Bar --- */
        #bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background-color: var(--nav-bg-color);
            box-shadow: 0 -4px 15px rgba(0,0,0,0.4);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: center; /* Center the buttons */
            align-items: center;
            padding: 12px 0;
            gap: 10px; /* Space between buttons */
            height: 75px;
        }

        .channel-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-color-inactive); /* Use inactive text color */
            background-color: var(--nav-btn-bg-color); /* Use inactive button color */
            border-radius: 12px; /* Rounded corners */
            width: 60px;
            height: 55px;
            transition: all 0.2s ease-in-out;
            font-size: 1.1rem; /* Larger font size */
            font-weight: 700;
            position: relative;
            border: 2px solid transparent;
        }

        .channel-button:hover {
            transform: translateY(-3px);
            color: var(--text-color); /* Use active text color on hover */
        }

        .channel-button.active {
            color: var(--text-color); /* Use active text color */
            background-color: var(--nav-btn-active-bg-color); /* Use active button color */
            border-color: #6ee7b7; /* emerald-200 for active border */
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.7); /* Adjusted shadow to match active color */
        }

        .audio-indicator {
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 0.8rem;
            color: #fde047; /* yellow-300 */
        }

        /* --- Fullscreen Mode --- */
        body.fullscreen-mode .main-content {
            display: none; /* Hide grid view */
        }
        body.fullscreen-mode #bottom-nav {
            display: none; /* Hide bottom nav */
        }

        #fullscreen-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            background: #000;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }

        body.fullscreen-mode #fullscreen-container {
            display: flex;
        }

        #fullscreen-container .video-container {
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        /* --- Fullscreen Controls --- */
        #fullscreen-controls {
            position: absolute;
            inset: 0;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 2rem;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent 25%, transparent 75%, rgba(0,0,0,0.5));
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        #fullscreen-container:hover #fullscreen-controls,
        #fullscreen-container.touch-active #fullscreen-controls {
            opacity: 1;
        }

        .fullscreen-top-controls, .fullscreen-bottom-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fullscreen-bottom-controls {
            justify-content: center;
            gap: 2rem;
        }

        .fullscreen-channel-name {
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 5px #000;
        }

        .fs-btn {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .fs-btn:hover {
            transform: scale(1.1);
            background: rgba(55, 65, 81, 0.9);
        }
    </style>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P5QLH7TD" height="0" width="0" style="display:none"></iframe></noscript>

    <main class="main-content">
        <h1 class="text-3xl font-bold text-center mb-2">爪驻 注专爪</h1>
        <p class="text-center text-gray-400 mb-6">爪 注 住驻专 注专抓  住祝 转 转爪</p>
        <div id="video-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
            <!-- Video players will be inserted here -->
        </div>
        <p id="no-channel-message" class="text-center text-gray-400 mt-10 text-lg">砖 专 注专抓 转驻专 转转</p>
    </main>

    <!-- New Footer Section for additional links and information -->
    <footer class="mt-10 text-center text-sm text-gray-400">
        <div class="mb-2"> 转转 专 :</div>
        <a href="https://mistralnet.github.io/radio" class="inline-block bg-indigo-600 hover:bg-indigo-500 text-white py-2 px-4 rounded mb-4"> 转转 专</a>
        <div class="flex justify-center gap-4 flex-wrap mb-4">
            <a href="https://mistralnet.github.io/radio/" class="text-blue-400 hover:text-blue-300">Radio</a>
            <a href="https://mistralnet.github.io/radio/tv.html" class="text-blue-400 hover:text-blue-300">TV</a>
            <a href="https://mistralnet.github.io/radio/tv2.html" class="text-blue-400 hover:text-blue-300">TV2</a>
            <a href="https://mistralnet.github.io/radio/tv3.html" class="text-blue-400 hover:text-blue-300">TV3</a>
            <a href="https://mistralnet.github.io/radio/tv4.html" class="text-blue-400 hover:text-blue-300">TV4</a>
        </div>
        <div class="version-info">
            专住 3
        </div>
    </footer>

    <!-- Container for the fullscreen player -->
    <div id="fullscreen-container">
        <!-- The single fullscreen video player will be injected here -->
    </div>

    <!-- Redesigned Bottom Navigation Bar -->
    <nav id="bottom-nav">
        <!-- Channel buttons will be dynamically inserted here -->
    </nav>

    <script>
        // --- Configuration and State ---
        const channels = {
            kan11: { name: ' 11', short: '11', type: 'hls', url: 'https://kan11w.media.kan.org.il/hls/live/2105694/2105694/source1_4k/chunklist.m3u8' },
            news12: { name: '砖转 12', short: '12', type: 'iframe', url: 'https://www.mako.co.il/AjaxPage?jspName=embedHTML5video.jsp&galleryChannelId=798cfb1e06667910VgnVCM200000650a10acRCRD&videoChannelId=7690b3a2a4ac5910VgnVCM100000650a10acRCRD&vcmid=003432e70df02310VgnVCM100000290b320aRCRD', muteParam: 'muted' },
            news13: { name: '砖转 13', short: '13', type: 'hls', url: 'https://d198ztbnlup2iq.cloudfront.net/out/v1/2d9050c90fb94df8b78d1d98306a1a65/index.m3u8' },
            // Replaced YouTube with a more reliable HLS stream for Channel 14
            now14: { name: '注砖 14', short: '14', type: 'hls', url: 'https://now14.g-mana.live/media/91517651-71c1-4775-a85f-dedf4df89f92/main.m3u8' },
            i24news: { name: 'i24NEWS', short: 'i24', type: 'hls', url: 'https://bcovlive-a.akamaihd.net/d89ede8094c741b7924120b27764153c/eu-central-1/5377161796001/profile_0/chunklist.m3u8' }
        };

        // Changed from let to var for broader compatibility/global scope certainty
        var activeChannels = [];
        var activeAudioKey = null; // Starts null, so all players are muted initially
        // New Set to track channels that have been loaded at least once in the current session
        var sessionLoadedChannels = new Set();
        var fullscreenKey = null; // Moved for clarity with other var declarations

        // Object to store Hls.js instances for proper cleanup when channels are removed
        var hlsInstances = {}; 

        const grid = document.getElementById('video-grid');
        const message = document.getElementById('no-channel-message');
        const bottomNavContainer = document.getElementById('bottom-nav');
        const fullscreenContainer = document.getElementById('fullscreen-container');

        // --- Inactivity Timer Variables and Functions ---
        var userActivityTimeout; // Changed to var
        const INACTIVITY_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes in milliseconds

        /**
         * Resets the inactivity timer. If no activity is detected for 10 minutes,
         * the active audio channel will be muted.
         */
        function resetActivityTimer() {
            clearTimeout(userActivityTimeout);
            userActivityTimeout = setTimeout(() => {
                // Only mute if there are currently active channels and audio is playing
                if (activeChannels.length > 0 && activeAudioKey !== null) {
                    activeAudioKey = null; // Mute all audio
                    console.log('Inactivity detected, muting all channels.');
                    render(); // Re-render to apply the muted state
                }
            }, INACTIVITY_TIMEOUT_MS);
        }

        // Attach global activity listeners to reset the timer
        document.addEventListener('mousemove', resetActivityTimer);
        document.addEventListener('keydown', resetActivityTimer);
        document.addEventListener('touchstart', resetActivityTimer);
        document.addEventListener('click', resetActivityTimer); // General clicks

        // --- Core Functions ---

        /**
         * Cleans up existing video players by pausing them and destroying HLS instances.
         * This prevents audio from continuing in the background when players are removed.
         * @param {HTMLElement} container - The container element (e.g., video-grid or fullscreen-container).
         */
        function cleanupPlayers(container) {
            // Select all .video-container elements within the given container
            Array.from(container.querySelectorAll('.video-container')).forEach(box => {
                const key = box.dataset.channelKey; // Get the channel key from data attribute
                const playerElement = box.querySelector('video') || box.querySelector('iframe');

                if (playerElement && playerElement.tagName === 'VIDEO') {
                    // For <video> elements, pause and destroy HLS instance if it exists
                    playerElement.pause();
                    if (hlsInstances[key]) {
                        console.log(`Destroying HLS instance for channel: ${key}`);
                        hlsInstances[key].destroy(); // Clean up HLS.js resources
                        delete hlsInstances[key];    // Remove from our tracking object
                    }
                }
                // For <iframe> elements, we cannot directly control their internal state
                // Removing them from the DOM is the primary way to stop them.
            });
            container.innerHTML = ''; // Clear the container's HTML after explicit cleanup
        }


        /**
         * Main render function. This function is responsible for updating the UI
         * based on the current state (active channels, fullscreen, active audio).
         * It first cleans up existing players to prevent audio issues.
         */
        function render() {
            // Always clean up existing players from both possible containers before re-rendering
            cleanupPlayers(grid);
            cleanupPlayers(fullscreenContainer);

            // Access fullscreenKey without needing 'var' here as it's already declared
            if (fullscreenKey) { 
                // If a channel is in fullscreen mode, show the fullscreen container
                document.body.classList.add('fullscreen-mode');
                renderFullscreenView();
            } else {
                // If not in fullscreen, show the grid view and hide the fullscreen container
                document.body.classList.remove('fullscreen-mode');
                renderGridView();
            }
            updateChannelButtonsUI(); // Update the bottom navigation buttons' appearance
            feather.replace();        // Redraw Feather icons
        }

        /**
         * Renders the grid of active video players in the main content area.
         */
        function renderGridView() {
            // Show or hide the "no channel selected" message based on active channels
            message.style.display = activeChannels.length > 0 ? 'none' : 'block';

            activeChannels.forEach(key => {
                // Create and append a player container for each active channel
                const box = createPlayerContainer(key);
                grid.appendChild(box);
            });
        }

        /**
         * Renders the single fullscreen video player and its controls.
         */
        function renderFullscreenView() {
            if (!fullscreenKey) return; // Do nothing if no channel is designated for fullscreen

            const box = createPlayerContainer(fullscreenKey); // Create the player for the fullscreen channel
            const controls = createFullscreenControls(fullscreenKey); // Create fullscreen specific controls
            box.appendChild(controls); // Add controls to the player box

            fullscreenContainer.appendChild(box); // Add the player box (with controls) to the fullscreen container
        }

        /**
         * Creates a single player container (for grid or fullscreen display).
         * This function handles both HLS (<video>) and iframe players.
         * @param {string} key - The channel key (e.g., 'kan11').
         * @returns {HTMLElement} The container div with the player element inside.
         */
        function createPlayerContainer(key) {
            const ch = channels[key];
            const box = document.createElement('div');
            box.className = 'video-container';
            box.dataset.channelKey = key; // Store the channel key as a data attribute

            let playerElement;
            // Determine if this channel should have audio based on activeAudioKey
            const wantsAudio = key === activeAudioKey;

            if (ch.type === 'hls') {
                playerElement = document.createElement('video');
                playerElement.autoplay = true;      // Start playing automatically
                playerElement.playsInline = true;   // Important for mobile playback
                playerElement.muted = !wantsAudio;  // Mute if not the designated active audio channel

                if (Hls.isSupported()) {
                    // Ensure any old Hls instance for this key is destroyed before creating a new one
                    if (hlsInstances[key]) {
                        hlsInstances[key].destroy();
                        delete hlsInstances[key];
                    }
                    const hls = new Hls({ enableWorker: true, lowLatencyMode: true });
                    hls.loadSource(ch.url);
                    hls.attachMedia(playerElement);
                    hlsInstances[key] = hls; // Store the new Hls instance

                    hls.on(Hls.Events.ERROR, (event, data) => {
                        if (data.fatal) {
                            console.error(`HLS fatal error for channel ${key}:`, data);
                            // Attempt to recover from common errors
                            if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                                hls.recoverMediaError();
                            } else if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                                hls.loadSource(ch.url); // Try reloading source for network errors
                            }
                        }
                    });
                } else {
                    // Fallback for browsers not supporting HLS.js
                    playerElement.src = ch.url;
                }
            } else { // iframe for Channel 12 (and potentially others)
                playerElement = document.createElement('iframe');
                playerElement.allow = 'autoplay; fullscreen'; // Allow autoplay and fullscreen
                // Build the iframe src with autoplay and mute parameters.
                // It will always try to autoplay, but be muted if not the active audio channel.
                playerElement.src = buildUrlWithParams(ch.url, !wantsAudio, ch.muteParam);
            }

            box.appendChild(playerElement);
            // Only add grid view controls if not in fullscreen mode
            if (!fullscreenKey) {
                box.appendChild(createGridControlsOverlay(key, ch.name));
            }
            return box;
        }

        /**
         * Builds an iframe URL with autoplay and mute parameters.
         * Corrected logic: Always requests autoplay, but sets the mute parameter
         * based on whether the channel `isMuted`.
         * @param {string} base - The base URL of the iframe content.
         * @param {boolean} isMuted - True if the stream should be muted, false otherwise.
         * @param {string} muteParam - The name of the mute parameter in the URL (e.g., 'muted').
         * @returns {string} The final URL with parameters appended.
         */
        function buildUrlWithParams(base, isMuted, muteParam = 'muted') {
            try {
                let url = base;
                url += `&autoplay=true`; // Always try to autoplay the iframe content
                url += `&${muteParam}=${isMuted ? 'true' : 'false'}`; // Set mute state
                return url;
            } catch (e) {
                console.error("Error building URL for iframe:", e);
                return base; // Return original base URL on error
            }
        }

        // --- UI Creation Functions ---

        /**
         * Creates the redesigned channel buttons for the bottom navigation bar.
         * These buttons allow users to add/remove channels from the grid.
         */
        function createChannelButtons() {
            bottomNavContainer.innerHTML = ''; // Clear existing buttons
            Object.entries(channels).forEach(([key, ch]) => {
                const btn = document.createElement('button');
                btn.className = 'channel-button';
                btn.dataset.channel = key; // Store channel key for easy lookup
                btn.innerHTML = `
                    <span class="audio-indicator"></span>
                    <span>${ch.short}</span>
                `;
                btn.onclick = () => toggleChannel(key); // Attach click handler
                bottomNavContainer.appendChild(btn);
            });
        }

        /**
         * Updates the visual state of the bottom navigation buttons,
         * highlighting active channels and showing the audio indicator.
         */
        function updateChannelButtonsUI() {
            document.querySelectorAll('.channel-button').forEach(btn => {
                const key = btn.dataset.channel;
                const audioIndicator = btn.querySelector('.audio-indicator');

                // Toggle 'active' class based on whether the channel is in activeChannels
                btn.classList.toggle('active', activeChannels.includes(key));

                // Display audio indicator () only if the channel is active AND is the audio source
                if (audioIndicator) {
                    audioIndicator.innerHTML = (activeChannels.includes(key) && key === activeAudioKey) ? '' : '';
                }
            });
        }

        /**
         * Creates the simple overlay with mute and fullscreen buttons for grid view.
         * @param {string} key - The channel key.
         * @param {string} name - The channel name.
         * @returns {HTMLElement} The overlay div for grid view.
         */
        function createGridControlsOverlay(key, name) {
            const overlay = document.createElement('div');
            overlay.className = 'grid-controls-overlay';

            const nameBar = document.createElement('div');
            nameBar.className = 'channel-name-bar';
            nameBar.textContent = name;

            const controlsWrapper = document.createElement('div');
            controlsWrapper.className = 'grid-control-buttons';

            const soundBtn = document.createElement('button');
            soundBtn.className = 'control-btn';
            // Set icon based on whether this channel is the active audio source
            soundBtn.innerHTML = key === activeAudioKey ? '<i data-feather="volume-2"></i>' : '<i data-feather="volume-x"></i>';
            soundBtn.onclick = (e) => { e.stopPropagation(); toggleAudio(key); };

            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.className = 'control-btn';
            fullscreenBtn.innerHTML = '<i data-feather="maximize"></i>';
            fullscreenBtn.onclick = (e) => { e.stopPropagation(); toggleFullscreen(key); };

            controlsWrapper.append(soundBtn, fullscreenBtn);
            overlay.append(nameBar, controlsWrapper);
            return overlay;
        }

        /**
         * Creates the new, comprehensive controls for the fullscreen view.
         * Includes exit, sound, and channel zapping buttons.
         * @param {string} key - The channel key currently in fullscreen.
         * @returns {HTMLElement} The fullscreen controls div.
         */
        function createFullscreenControls(key) {
            const ch = channels[key];
            const controls = document.createElement('div');
            controls.id = 'fullscreen-controls';

            // Check if there are other channels to zap to
            const hasPrevNext = activeChannels.length > 1;

            controls.innerHTML = `
                <div class="fullscreen-top-controls">
                    <span class="fullscreen-channel-name">${ch.name}</span>
                    <button class="fs-btn" id="exit-fs-btn" title="专 转爪转 专砖转">
                        <i data-feather="minimize-2" style="width: 32px; height: 32px;"></i>
                    </button>
                </div>
                <div class="fullscreen-bottom-controls">
                    <button class="fs-btn" id="prev-ch-btn" title="注专抓 拽" ${!hasPrevNext ? 'style="display:none;"' : ''}>
                        <i data-feather="arrow-right" style="width: 32px; height: 32px;"></i>
                    </button>
                    <button class="fs-btn" id="fs-sound-btn" title="驻注/ 砖注">
                        ${key === activeAudioKey ? '<i data-feather="volume-2"></i>' : '<i data-feather="volume-x"></i>'}
                    </button>
                    <button class="fs-btn" id="next-ch-btn" title="注专抓 " ${!hasPrevNext ? 'style="display:none;"' : ''}>
                        <i data-feather="arrow-left"></i>
                    </button>
                </div>
            `;
            // Set size for Feather icons inside buttons
            controls.querySelectorAll('.fs-btn i').forEach(icon => {
                icon.style.width = '32px';
                icon.style.height = '32px';
            });

            // Attach event listeners for fullscreen controls
            controls.querySelector('#exit-fs-btn').onclick = (e) => { e.stopPropagation(); toggleFullscreen(null); };
            controls.querySelector('#fs-sound-btn').onclick = (e) => { e.stopPropagation(); toggleAudio(key); };
            controls.querySelector('#next-ch-btn').onclick = (e) => { e.stopPropagation(); zapChannel('next'); };
            controls.querySelector('#prev-ch-btn').onclick = (e) => { e.stopPropagation(); zapChannel('prev'); };

            return controls;
        }

        // --- Event Handlers and Toggles ---

        /**
         * Toggles a channel's visibility in the grid and manages its audio state.
         * @param {string} key - The channel key to add or remove.
         */
        function toggleChannel(key) {
            resetActivityTimer(); // User interacted, reset inactivity timer

            const index = activeChannels.indexOf(key);
            if (index > -1) {
                // Channel is currently active, so remove it
                activeChannels.splice(index, 1);
                // If the removed channel was the active audio source, find a new active audio key
                // or set to null if no other active channels.
                if (activeAudioKey === key) {
                    activeAudioKey = activeChannels.length > 0 ? activeChannels[0] : null;
                }
                // If the removed channel was in fullscreen, exit fullscreen mode
                if (fullscreenKey === key) {
                    toggleFullscreen(null);
                }
            } else {
                // Channel is not active, so add it
                activeChannels.unshift(key); // Add to the beginning

                // Logic for "first load muted":
                if (!sessionLoadedChannels.has(key)) {
                    // This is the first time this specific channel is added in the current session.
                    // It should *not* get audio automatically. The current activeAudioKey should remain.
                    console.log(`First load of channel ${key}. Will play muted. Current activeAudioKey remains: ${activeAudioKey}`);
                    // No change to activeAudioKey here. It retains its current value (could be null or another channel).
                } else {
                    // This channel has been loaded before in this session (it's being re-added).
                    // It should now become the active audio source, muting any other.
                    console.log(`Re-adding channel ${key}. It will now become the active audio source.`);
                    activeAudioKey = key;
                }
                sessionLoadedChannels.add(key); // Mark as loaded for this session
            }
            render(); // Re-render to apply all state changes

            // Final check: if no channels are left, ensure activeAudioKey is truly null.
            if (activeChannels.length === 0) {
                activeAudioKey = null; // Explicitly mute all
                render(); // Render again for a clean state, though previous render might have handled it.
            }
        }

        /**
         * Toggles audio for a specific channel. Ensures only one channel can have audio at a time.
         * If the current channel has audio, it mutes it. Otherwise, it makes it the active audio source.
         * @param {string} key - The channel key whose audio state is to be toggled.
         */
        function toggleAudio(key) {
            resetActivityTimer(); // User interacted, reset inactivity timer

            if (activeAudioKey === key) {
                // If this channel is currently playing audio, mute it (set activeAudioKey to null)
                activeAudioKey = null;
            } else {
                // If another channel is playing or all are muted, switch audio to this channel
                activeAudioKey = key;
            }
            render(); // Re-render to apply the new muted/unmuted state to all players
        }

        /**
         * Enters or exits fullscreen mode for a specific channel.
         * @param {string|null} key - The channel to make fullscreen, or null to exit fullscreen.
         */
        function toggleFullscreen(key) {
            resetActivityTimer(); // User interacted, reset inactivity timer

            fullscreenKey = key; // Set the fullscreen channel key

            if (key) {
                // If entering fullscreen, ensure the channel is in activeChannels
                if (!activeChannels.includes(key)) {
                    activeChannels.unshift(key); // Add it if not present
                }
                // When entering fullscreen, it always becomes the active audio source
                activeAudioKey = key;
            } else {
                // If exiting fullscreen, re-evaluate activeAudioKey.
                // If no channels are left in the grid, ensure audio is off.
                if (activeChannels.length === 0) {
                    activeAudioKey = null;
                } else {
                    // When exiting fullscreen, the audio should revert to the first active channel in the grid
                    activeAudioKey = activeChannels[0];
                }
            }
            render(); // Re-render the UI to transition to/from fullscreen
        }

        /**
         * "Zaps" (switches) to the next or previous channel in fullscreen view.
         * @param {'next'|'prev'} direction - The direction to switch ('next' or 'prev').
         */
        function zapChannel(direction) {
            resetActivityTimer(); // User interacted, reset inactivity timer

            // Only allow zapping if a channel is in fullscreen and there's more than one active channel
            if (!fullscreenKey || activeChannels.length <= 1) return;

            const currentIndex = activeChannels.indexOf(fullscreenKey);
            let nextIndex;

            if (direction === 'next') {
                nextIndex = (currentIndex + 1) % activeChannels.length;
            } else { // 'prev'
                // Handle negative index for 'prev' to loop correctly
                nextIndex = (currentIndex - 1 + activeChannels.length) % activeChannels.length;
            }

            const newKey = activeChannels[nextIndex]; // Get the key of the next/previous channel
            fullscreenKey = newKey; // Update fullscreen channel
            activeAudioKey = newKey; // The new fullscreen channel always gets audio

            render(); // Re-render to show the new fullscreen channel
        }

        // --- Global Event Listeners (for keyboard navigation in fullscreen) ---
        document.addEventListener('keydown', (e) => {
            if (!fullscreenKey) return; // Only process key events if in fullscreen

            if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                e.preventDefault(); // Prevent default browser scroll behavior
                zapChannel('prev'); // RTL layout: Right arrow goes to previous item
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                e.preventDefault(); // Prevent default browser scroll behavior
                zapChannel('next'); // RTL layout: Left arrow goes to next item
            } else if (e.key === 'Escape') {
                e.preventDefault();
                toggleFullscreen(null); // Exit fullscreen on Escape key
            } else if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                toggleAudio(fullscreenKey); // Toggle audio for the current fullscreen channel
            }
        });

        // Add touch-active class to show controls on touch for fullscreen
        var touchTimeout; // Changed to var
        fullscreenContainer.addEventListener('touchstart', e => {
            fullscreenContainer.classList.add('touch-active');
            clearTimeout(touchTimeout);
            touchTimeout = setTimeout(() => {
                fullscreenContainer.classList.remove('touch-active');
            }, 3000); // Remove touch-active class after 3 seconds of no further touch
        }, { passive: true }); // Use passive listener for better scroll performance

        // --- Initial Load and Window Resize ---
        /**
         * Initializes the application: creates channel buttons, renders initial view,
         * and starts the inactivity timer.
         */
        function initialize() {
            createChannelButtons();
            // Initial render: activeAudioKey is null by default, ensuring all players start muted.
            render();
            // Start the inactivity timer immediately after initial load
            resetActivityTimer();
            // Adjust body padding to account for the fixed bottom navigation bar
            const navHeight = bottomNavContainer.offsetHeight;
            document.body.style.paddingBottom = `${navHeight}px`;
        }

        // Call initialize when the window is fully loaded
        window.onload = initialize;

        // Re-adjust body padding if window is resized (e.g., orientation change on mobile)
        window.onresize = () => {
             const navHeight = bottomNavContainer.offsetHeight;
             document.body.style.paddingBottom = `${navHeight}px`;
        };
    </script>
</body>
</html>
